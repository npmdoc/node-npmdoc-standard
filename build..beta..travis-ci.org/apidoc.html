<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://standardjs.com"

    >standard (v9.0.2)</a>
</h1>
<h4>JavaScript Standard Style</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard">module standard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine">
            function <span class="apidocSignatureSpan">standard.</span>eslint.CLIEngine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester">
            function <span class="apidocSignatureSpan">standard.</span>eslint.RuleTester
            <span class="apidocSignatureSpan">(testerConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode">
            function <span class="apidocSignatureSpan">standard.</span>eslint.SourceCode
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslint.CLIEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslint.RuleTester.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslint.SourceCode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslint.linter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.</span>eslintConfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">standard.</span>cmd</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint">module standard.eslint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine">
            function <span class="apidocSignatureSpan">standard.eslint.</span>CLIEngine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester">
            function <span class="apidocSignatureSpan">standard.eslint.</span>RuleTester
            <span class="apidocSignatureSpan">(testerConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode">
            function <span class="apidocSignatureSpan">standard.eslint.</span>SourceCode
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">standard.eslint.</span>linter</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.CLIEngine">module standard.eslint.CLIEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.CLIEngine">
            function <span class="apidocSignatureSpan">standard.eslint.</span>CLIEngine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.getErrorResults">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>getErrorResults
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.getFormatter">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>getFormatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.outputFixes">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>outputFixes
            <span class="apidocSignatureSpan">(report)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.CLIEngine.prototype">module standard.eslint.CLIEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.addPlugin">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>addPlugin
            <span class="apidocSignatureSpan">(name, pluginobject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.constructor">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.executeOnFiles">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>executeOnFiles
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.executeOnText">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>executeOnText
            <span class="apidocSignatureSpan">(text, filename, warnIgnored)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.getConfigForFile">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>getConfigForFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.getFormatter">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>getFormatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.isPathIgnored">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>isPathIgnored
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.CLIEngine.prototype.resolveFileGlobPatterns">
            function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>resolveFileGlobPatterns
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.RuleTester">module standard.eslint.RuleTester</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.RuleTester">
            function <span class="apidocSignatureSpan">standard.eslint.</span>RuleTester
            <span class="apidocSignatureSpan">(testerConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.describe">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>describe
            <span class="apidocSignatureSpan">(text, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.getDefaultConfig">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>getDefaultConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.it">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>it
            <span class="apidocSignatureSpan">(text, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.resetDefaultConfig">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>resetDefaultConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.setDefaultConfig">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>setDefaultConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.RuleTester.prototype">module standard.eslint.RuleTester.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.prototype.defineRule">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.prototype.</span>defineRule
            <span class="apidocSignatureSpan">(name, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.RuleTester.prototype.run">
            function <span class="apidocSignatureSpan">standard.eslint.RuleTester.prototype.</span>run
            <span class="apidocSignatureSpan">(ruleName, rule, test)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.SourceCode">module standard.eslint.SourceCode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.SourceCode">
            function <span class="apidocSignatureSpan">standard.eslint.</span>SourceCode
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.splitLines">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.</span>splitLines
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.SourceCode.prototype">module standard.eslint.SourceCode.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.constructor">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getAllComments">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getAllComments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getComments">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getComments
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getIndexFromLoc">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getIndexFromLoc
            <span class="apidocSignatureSpan">(loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getJSDocComment">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getJSDocComment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getLines">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getLines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getLocFromIndex">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getLocFromIndex
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getNodeByRangeIndex">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getNodeByRangeIndex
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.getText">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getText
            <span class="apidocSignatureSpan">(node, beforeCount, afterCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.SourceCode.prototype.isSpaceBetweenTokens">
            function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>isSpaceBetweenTokens
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.standard.eslint.linter">module standard.eslint.linter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.defaults">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.defineRule">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defineRule
            <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.defineRules">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defineRules
            <span class="apidocSignatureSpan">(rulesToDefine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getAllComments">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getAllComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getAncestors">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getAncestors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getComments">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getDeclaredVariables">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getDeclaredVariables
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getFilename">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getFirstToken">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFirstToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getFirstTokens">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFirstTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getJSDocComment">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getJSDocComment
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getLastToken">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getLastToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getLastTokens">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getLastTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getNodeByRangeIndex">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getNodeByRangeIndex
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getRules">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getScope">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getSource">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSource
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getSourceCode">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSourceCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getSourceLines">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSourceLines
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokenAfter">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokenBefore">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokenByRangeStart">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenByRangeStart
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokens">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokensAfter">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokensBefore">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.getTokensBetween">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensBetween
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.markVariableAsUsed">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>markVariableAsUsed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.report">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>report
            <span class="apidocSignatureSpan">(ruleId, severity, node, location, message, opts, fix, meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.reset">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.standard.eslint.linter.verify">
            function <span class="apidocSignatureSpan">standard.eslint.linter.</span>verify
            <span class="apidocSignatureSpan">(textOrSourceCode, config, filenameOrOptions, saveState)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">standard.eslint.linter.</span>_maxListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">standard.eslint.linter.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard" id="apidoc.module.standard">module standard</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine" id="apidoc.element.standard.eslint.CLIEngine">
        function <span class="apidocSignatureSpan">standard.</span>eslint.CLIEngine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester" id="apidoc.element.standard.eslint.RuleTester">
        function <span class="apidocSignatureSpan">standard.</span>eslint.RuleTester
        <span class="apidocSignatureSpan">(testerConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleTester(testerConfig) {

<span class="apidocCodeCommentSpan">    /**
     * The configuration to use for this tester. Combination of the tester
     * configuration and the default configuration.
     * @type {Object}
     */
</span>    this.testerConfig = lodash.merge(

        // we have to clone because merge uses the first argument for recipient
        lodash.cloneDeep(defaultConfig),
        testerConfig
    );

    /**
     * Rule definitions to define before tests.
     * @type {Object}
     */
    this.rules = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode" id="apidoc.element.standard.eslint.SourceCode">
        function <span class="apidocSignatureSpan">standard.</span>eslint.SourceCode
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint" id="apidoc.module.standard.eslint">module standard.eslint</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine" id="apidoc.element.standard.eslint.CLIEngine">
        function <span class="apidocSignatureSpan">standard.eslint.</span>CLIEngine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester" id="apidoc.element.standard.eslint.RuleTester">
        function <span class="apidocSignatureSpan">standard.eslint.</span>RuleTester
        <span class="apidocSignatureSpan">(testerConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleTester(testerConfig) {

<span class="apidocCodeCommentSpan">    /**
     * The configuration to use for this tester. Combination of the tester
     * configuration and the default configuration.
     * @type {Object}
     */
</span>    this.testerConfig = lodash.merge(

        // we have to clone because merge uses the first argument for recipient
        lodash.cloneDeep(defaultConfig),
        testerConfig
    );

    /**
     * Rule definitions to define before tests.
     * @type {Object}
     */
    this.rules = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode" id="apidoc.element.standard.eslint.SourceCode">
        function <span class="apidocSignatureSpan">standard.eslint.</span>SourceCode
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.CLIEngine" id="apidoc.module.standard.eslint.CLIEngine">module standard.eslint.CLIEngine</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.CLIEngine" id="apidoc.element.standard.eslint.CLIEngine.CLIEngine">
        function <span class="apidocSignatureSpan">standard.eslint.</span>CLIEngine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.getErrorResults" id="apidoc.element.standard.eslint.CLIEngine.getErrorResults">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>getErrorResults
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorResults = function (results) {
    const filtered = [];

    results.forEach(result =&#x3e; {
        const filteredMessages = result.messages.filter(isErrorMessage);

        if (filteredMessages.length &#x3e; 0) {
            filtered.push(
                Object.assign(result, {
                    messages: filteredMessages,
                    errorCount: filteredMessages.length,
                    warningCount: 0
                })
            );
        }
    });

    return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.getFormatter" id="apidoc.element.standard.eslint.CLIEngine.getFormatter">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>getFormatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormatter = function (format) {

    let formatterPath;

    // default is stylish
    format = format || &#x22;stylish&#x22;;

    // only strings are valid formatters
    if (typeof format === &#x22;string&#x22;) {

        // replace \ with / for Windows compatibility
        format = format.replace(/\\/g, &#x22;/&#x22;);

        // if there&#x27;s a slash, then it&#x27;s a file
        if (format.indexOf(&#x22;/&#x22;) &#x3e; -1) {
            const cwd = this.options ? this.options.cwd : process.cwd();

            formatterPath = path.resolve(cwd, format);
        } else {
            formatterPath = `./formatters/${format}`;
        }

        try {
            return require(formatterPath);
        } catch (ex) {
            ex.message = `There was a problem loading formatter: ${formatterPath}\nError: ${ex.message}`;
            throw ex;
        }

    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.outputFixes" id="apidoc.element.standard.eslint.CLIEngine.outputFixes">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.</span>outputFixes
        <span class="apidocSignatureSpan">(report)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFixes = function (report) {
    report.results.filter(result =&#x3e; result.hasOwnProperty(&#x22;output&#x22;)).forEach(result =&#x3e; {
        fs.writeFileSync(result.filePath, result.output);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.CLIEngine.prototype" id="apidoc.module.standard.eslint.CLIEngine.prototype">module standard.eslint.CLIEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.addPlugin" id="apidoc.element.standard.eslint.CLIEngine.prototype.addPlugin">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>addPlugin
        <span class="apidocSignatureSpan">(name, pluginobject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPlugin(name, pluginobject) {
    Plugins.define(name, pluginobject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.constructor" id="apidoc.element.standard.eslint.CLIEngine.prototype.constructor">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.executeOnFiles" id="apidoc.element.standard.eslint.CLIEngine.prototype.executeOnFiles">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>executeOnFiles
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnFiles(patterns) {
    const results = [],
        options = this.options,
        fileCache = this._fileCache,
        configHelper = new Config(options);
    let prevConfig; // the previous configuration used

<span class="apidocCodeCommentSpan">    /**
     * Calculates the hash of the config file used to validate a given file
     * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash
     * @returns {string}         the hash of the config
     */
</span>    function hashOfConfigFor(filename) {
        const config = configHelper.getConfig(filename);

        if (!prevConfig) {
            prevConfig = {};
        }

        // reuse the previously hashed config if the config hasn&#x27;t changed
        if (prevConfig.config !== config) {

            /*
             * config changed so we need to calculate the hash of the config
             * and the hash of the plugins being used
             */
            prevConfig.config = config;

            const eslintVersion = pkg.version;

            prevConfig.hash = hash(`${eslintVersion}_${stringify(config)}`);
        }

        return prevConfig.hash;
    }

    /**
     * Executes the linter on a file defined by the `filename`. Skips
     * unsupported file extensions and any files that are already linted.
     * @param {string} filename The resolved filename of the file to be linted
     * @param {boolean} warnIgnored always warn when a file is ignored
     * @returns {void}
     */
    function executeOnFile(filename, warnIgnored) {
        let hashOfConfig,
            descriptor;

        if (warnIgnored) {
            results.push(createIgnoreResult(filename, options.cwd));
            return;
        }

        if (options.cache) {

            /*
             * get the descriptor for this file
             * with the metadata and the flag that determines if
             * the file has changed
             */
            descriptor = fileCache.getFileDescriptor(filename);
            const meta = descriptor.meta || {};

            hashOfConfig = hashOfConfigFor(filename);

            const changed = descriptor.changed || meta.hashOfConfig !== hashOfConfig;

            if (!changed) {
                debug(`Skipping file since hasn&#x27;t changed: ${filename}`);

                /*
                 * Add the the cached results (always will be 0 error and
                 * 0 warnings). We should not cache results for files that
                 * failed, in order to guarantee that next execution will
                 * process those files as well.
                 */
                results.push(descriptor.meta.results);

                // move to the next file
                return;
            }
        } else {
            fileCache.destroy();
        }

        debug(`Processing ${filename}`);

        const res = processFile(filename, configHelper, options);

        if (options.cache) {

            /*
             * if a file contains errors or warnings we don&#x27;t want to
             * store the file in the cache so we can guarantee that
             * next execution will also operate on this file
             */
            if (res.errorCount &#x3e; 0 || res.warningCount &#x3e; 0) {
                debug(`File has problems, skipping it: ${filename}`);

                // remove the entry from the cache
                fileCache.removeEntry(filename);
            } else {

                /*
                 * since the file passed we store the result here
                 * TODO: check this as we might not need to store the
                 * successful runs as it will always should be 0 errors and
                 * 0 warnings.
                 */
                descriptor.meta.hashOfConfig = hashOfConfig;
                descriptor.meta.results = res;
            }
        }

        results.push(res);
    }

    const startTime = Date.now();



    patterns = this.resolveFileGlobPatterns(patterns);
    const fileList = globUtil.listFilesToProcess(patterns, options);

    fileList.forEach(fileInfo =&#x3e; {
        executeOnFile(fileInfo.filename, fileInfo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.executeOnText" id="apidoc.element.standard.eslint.CLIEngine.prototype.executeOnText">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>executeOnText
        <span class="apidocSignatureSpan">(text, filename, warnIgnored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnText(text, filename, warnIgnored) {

    const results = [],
        options = this.options,
        configHelper = new Config(options),
        ignoredPaths = new IgnoredPaths(options);

    // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)
    if (filename &#x26;&#x26; !path.isAbsolute(filename)) {
        filename = path.resolve(options.cwd, filename);
    }

    if (filename &#x26;&#x26; ignoredPaths.contains(filename)) {
        if (warnIgnored) {
            results.push(createIgnoreResult(filename, options.cwd));
        }
    } else {
        results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig));
    }

    const stats = calculateStatsPerRun(results);

    return {
        results,
        errorCount: stats.errorCount,
        warningCount: stats.warningCount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.getConfigForFile" id="apidoc.element.standard.eslint.CLIEngine.prototype.getConfigForFile">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>getConfigForFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfigForFile(filePath) {
    const configHelper = new Config(this.options);

    return configHelper.getConfig(filePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.getFormatter" id="apidoc.element.standard.eslint.CLIEngine.prototype.getFormatter">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>getFormatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormatter = function (format) {

    let formatterPath;

    // default is stylish
    format = format || &#x22;stylish&#x22;;

    // only strings are valid formatters
    if (typeof format === &#x22;string&#x22;) {

        // replace \ with / for Windows compatibility
        format = format.replace(/\\/g, &#x22;/&#x22;);

        // if there&#x27;s a slash, then it&#x27;s a file
        if (format.indexOf(&#x22;/&#x22;) &#x3e; -1) {
            const cwd = this.options ? this.options.cwd : process.cwd();

            formatterPath = path.resolve(cwd, format);
        } else {
            formatterPath = `./formatters/${format}`;
        }

        try {
            return require(formatterPath);
        } catch (ex) {
            ex.message = `There was a problem loading formatter: ${formatterPath}\nError: ${ex.message}`;
            throw ex;
        }

    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.isPathIgnored" id="apidoc.element.standard.eslint.CLIEngine.prototype.isPathIgnored">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>isPathIgnored
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPathIgnored(filePath) {
    const resolvedPath = path.resolve(this.options.cwd, filePath);
    const ignoredPaths = new IgnoredPaths(this.options);

    return ignoredPaths.contains(resolvedPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.CLIEngine.prototype.resolveFileGlobPatterns" id="apidoc.element.standard.eslint.CLIEngine.prototype.resolveFileGlobPatterns">
        function <span class="apidocSignatureSpan">standard.eslint.CLIEngine.prototype.</span>resolveFileGlobPatterns
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveFileGlobPatterns(patterns) {
    return globUtil.resolveFileGlobPatterns(patterns, this.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.RuleTester" id="apidoc.module.standard.eslint.RuleTester">module standard.eslint.RuleTester</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.RuleTester" id="apidoc.element.standard.eslint.RuleTester.RuleTester">
        function <span class="apidocSignatureSpan">standard.eslint.</span>RuleTester
        <span class="apidocSignatureSpan">(testerConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleTester(testerConfig) {

<span class="apidocCodeCommentSpan">    /**
     * The configuration to use for this tester. Combination of the tester
     * configuration and the default configuration.
     * @type {Object}
     */
</span>    this.testerConfig = lodash.merge(

        // we have to clone because merge uses the first argument for recipient
        lodash.cloneDeep(defaultConfig),
        testerConfig
    );

    /**
     * Rule definitions to define before tests.
     * @type {Object}
     */
    this.rules = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.describe" id="apidoc.element.standard.eslint.RuleTester.describe">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>describe
        <span class="apidocSignatureSpan">(text, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultHandler(text, method) {
    return method.apply(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.getDefaultConfig" id="apidoc.element.standard.eslint.RuleTester.getDefaultConfig">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>getDefaultConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultConfig = function () {
    return defaultConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.it" id="apidoc.element.standard.eslint.RuleTester.it">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>it
        <span class="apidocSignatureSpan">(text, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultHandler(text, method) {
    return method.apply(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.resetDefaultConfig" id="apidoc.element.standard.eslint.RuleTester.resetDefaultConfig">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>resetDefaultConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetDefaultConfig = function () {
    defaultConfig = lodash.cloneDeep(testerDefaultConfig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.setDefaultConfig" id="apidoc.element.standard.eslint.RuleTester.setDefaultConfig">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.</span>setDefaultConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaultConfig = function (config) {
    if (typeof config !== &#x22;object&#x22;) {
        throw new Error(&#x22;RuleTester.setDefaultConfig: config must be an object&#x22;);
    }
    defaultConfig = config;

    // Make sure the rules object exists since it is assumed to exist later
    defaultConfig.rules = defaultConfig.rules || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.RuleTester.prototype" id="apidoc.module.standard.eslint.RuleTester.prototype">module standard.eslint.RuleTester.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.prototype.defineRule" id="apidoc.element.standard.eslint.RuleTester.prototype.defineRule">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.prototype.</span>defineRule
        <span class="apidocSignatureSpan">(name, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRule(name, rule) {
    this.rules[name] = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.RuleTester.prototype.run" id="apidoc.element.standard.eslint.RuleTester.prototype.run">
        function <span class="apidocSignatureSpan">standard.eslint.RuleTester.prototype.</span>run
        <span class="apidocSignatureSpan">(ruleName, rule, test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run(ruleName, rule, test) {

    const testerConfig = this.testerConfig,
        requiredScenarios = [&#x22;valid&#x22;, &#x22;invalid&#x22;],
        scenarioErrors = [],
        result = {};

    if (lodash.isNil(test) || typeof test !== &#x22;object&#x22;) {
        throw new Error(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);
    }

    requiredScenarios.forEach(scenarioType =&#x3e; {
        if (lodash.isNil(test[scenarioType])) {
            scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);
        }
    });

    if (scenarioErrors.length &#x3e; 0) {
        throw new Error([
            `Test Scenarios for rule ${ruleName} is invalid:`
        ].concat(scenarioErrors).join(&#x22;\n&#x22;));
    }

<span class="apidocCodeCommentSpan">    /* eslint-disable no-shadow */
</span>
    /**
     * Run the rule for the given item
     * @param {string} ruleName name of the rule
     * @param {string|Object} item Item to run the rule against
     * @returns {Object} Eslint run result
     * @private
     */
    function runRuleForItem(ruleName, item) {
        let config = lodash.cloneDeep(testerConfig),
            code, filename, beforeAST, afterAST;

        if (typeof item === &#x22;string&#x22;) {
            code = item;
        } else {
            code = item.code;

            // Assumes everything on the item is a config except for the
            // parameters used by this tester
            const itemConfig = lodash.omit(item, RuleTesterParameters);

            // Create the config object from the tester config and this item
            // specific configurations.
            config = lodash.merge(
                config,
                itemConfig
            );
        }

        if (item.filename) {
            filename = item.filename;
        }

        if (item.options) {
            const options = item.options.concat();

            options.unshift(1);
            config.rules[ruleName] = options;
        } else {
            config.rules[ruleName] = 1;
        }

        eslint.defineRule(ruleName, rule);

        const schema = validator.getRuleOptionsSchema(ruleName);

        if (schema) {
            validateSchema(schema);

            if (validateSchema.errors) {
                throw new Error([
                    `Schema for rule ${ruleName} is invalid:`
                ].concat(validateSchema.errors.map(error =&#x3e; `\t${error.field}: ${error.message}`)).join(&#x22;\n&#x22;));
            }
        }

        validator.validate(config, &#x22;rule-tester&#x22;);

        /*
         * Setup AST getters.
         * The goal is to check whether or not AST was modified when
         * running the rule under test.
         */
        eslint.reset();

        eslint.on(&#x22;Program&#x22;, node =&#x3e; {
            beforeAST = cloneDeeplyExcludesParent(node);
        });

        eslint.on(&#x22;Program:exit&#x22;, node =&#x3e; {
            afterAST = node;
        });

        // Freezes rule-context properties.
        const originalGet = rules.get;

        try {
            rules.get = function(ruleId) {
                const rule = originalGet(ruleId);

                if (typeof rule === &#x22;function&#x22;) {
                    return function(context) {
                        Object.freeze(context);
                        freezeDeeply(context.options);
                        freezeDeeply(context.settings);
                        freezeDeeply(context.parserOptions);

                        return rule(context);
                    };
                }
                return {
                    meta: rule.meta,
                    create(context) {
                        Object.freeze(context);
                        freezeDeeply(context.options);
                        freezeDeeply(context.settings);
                        freezeDeeply(context.parserOptions);

                        return rule.create(context);
                    }
                };

            };

            return {
                messages: eslint.verify(code, config, filename, true),
                beforeAST,
                afterAST: cloneDeeplyExcludesParent(afterAST)
            };
        } finally { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.SourceCode" id="apidoc.module.standard.eslint.SourceCode">module standard.eslint.SourceCode</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.SourceCode" id="apidoc.element.standard.eslint.SourceCode.SourceCode">
        function <span class="apidocSignatureSpan">standard.eslint.</span>SourceCode
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.splitLines" id="apidoc.element.standard.eslint.SourceCode.splitLines">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.</span>splitLines
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splitLines = function (text) {
    return text.split(astUtils.createGlobalLinebreakMatcher());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.SourceCode.prototype" id="apidoc.module.standard.eslint.SourceCode.prototype">module standard.eslint.SourceCode.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.constructor" id="apidoc.element.standard.eslint.SourceCode.prototype.constructor">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getAllComments" id="apidoc.element.standard.eslint.SourceCode.prototype.getAllComments">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getAllComments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllComments() {
    return this.ast.comments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getComments" id="apidoc.element.standard.eslint.SourceCode.prototype.getComments">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getComments
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments(node) {

    let leadingComments = node.leadingComments || [];
    const trailingComments = node.trailingComments || [];

<span class="apidocCodeCommentSpan">    /*
     * espree adds a &#x22;comments&#x22; array on Program nodes rather than
     * leadingComments/trailingComments. Comments are only left in the
     * Program node comments array if there is no executable code.
     */
</span>    if (node.type === &#x22;Program&#x22;) {
        if (node.body.length === 0) {
            leadingComments = node.comments;
        }
    }

    return {
        leading: leadingComments,
        trailing: trailingComments
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getIndexFromLoc" id="apidoc.element.standard.eslint.SourceCode.prototype.getIndexFromLoc">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getIndexFromLoc
        <span class="apidocSignatureSpan">(loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIndexFromLoc(loc) {
    if (typeof loc !== &#x22;object&#x22; || typeof loc.line !== &#x22;number&#x22; || typeof loc.column !== &#x22;number&#x22;) {
        throw new TypeError(&#x22;Expected `loc` to be an object with numeric `line` and `column` properties.&#x22;);
    }

    if (loc.line &#x3c;= 0) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
    }

    if (loc.line &#x3e; this.lineStartIndices.length) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines
 present).`);
    }

    const lineStartIndex = this.lineStartIndices[loc.line - 1];
    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
    const positionIndex = lineStartIndex + loc.column;

<span class="apidocCodeCommentSpan">    /*
     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of
     * the given line, provided that the line number is valid element of this.lines. Since the
     * last element of this.lines is an empty string for files with trailing newlines, add a
     * special case where getting the index for the first location after the end of the file
     * will return the length of the file, rather than throwing an error. This allows rules to
     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.
     */
</span>    if (
        loc.line === this.lineStartIndices.length &#x26;&#x26; positionIndex &#x3e; lineEndIndex ||
        loc.line &#x3c; this.lineStartIndices.length &#x26;&#x26; positionIndex &#x3e;= lineEndIndex
    ) {
        throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${
lineEndIndex - lineStartIndex}).`);
    }

    return positionIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getJSDocComment" id="apidoc.element.standard.eslint.SourceCode.prototype.getJSDocComment">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getJSDocComment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSDocComment(node) {

    let parent = node.parent;

    switch (node.type) {
        case &#x22;ClassDeclaration&#x22;:
        case &#x22;FunctionDeclaration&#x22;:
            if (looksLikeExport(parent)) {
                return findJSDocComment(parent.leadingComments, parent.loc.start.line);
            }
            return findJSDocComment(node.leadingComments, node.loc.start.line);

        case &#x22;ClassExpression&#x22;:
            return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);

        case &#x22;ArrowFunctionExpression&#x22;:
        case &#x22;FunctionExpression&#x22;:

            if (parent.type !== &#x22;CallExpression&#x22; &#x26;&#x26; parent.type !== &#x22;NewExpression&#x22;) {
                while (parent &#x26;&#x26; !parent.leadingComments &#x26;&#x26; !/Function/.test(parent.type) &#x26;&#x26; parent.type !== &#x22;MethodDefinition&#x22; &#x26;&#x26;
parent.type !== &#x22;Property&#x22;) {
                    parent = parent.parent;
                }

                return parent &#x26;&#x26; (parent.type !== &#x22;FunctionDeclaration&#x22;) ? findJSDocComment(parent.leadingComments, parent.loc.start
.line) : null;
            } else if (node.leadingComments) {
                return findJSDocComment(node.leadingComments, node.loc.start.line);
            }

        // falls through

        default:
            return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getLines" id="apidoc.element.standard.eslint.SourceCode.prototype.getLines">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getLines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLines() {
    return this.lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getLocFromIndex" id="apidoc.element.standard.eslint.SourceCode.prototype.getLocFromIndex">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getLocFromIndex
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLocFromIndex(index) {
    if (typeof index !== &#x22;number&#x22;) {
        throw new TypeError(&#x22;Expected `index` to be a number.&#x22;);
    }

    if (index &#x3c; 0 || index &#x3e; this.text.length) {
        throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
    }

<span class="apidocCodeCommentSpan">    /*
     * For an argument of this.text.length, return the location one &#x22;spot&#x22; past the last character
     * of the file. If the last character is a linebreak, the location will be column 0 of the next
     * line; otherwise, the location will be in the next column on the same line.
     *
     * See getIndexFromLoc for the motivation for this special case.
     */
</span>    if (index === this.text.length) {
        return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
    }

    /*
     * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could
     * be inserted into lineIndices to keep the list sorted.
     */
    const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);

    return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getNodeByRangeIndex" id="apidoc.element.standard.eslint.SourceCode.prototype.getNodeByRangeIndex">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getNodeByRangeIndex
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeByRangeIndex(index) {
    let result = null,
        resultParent = null;
    const traverser = new Traverser();

    traverser.traverse(this.ast, {
        enter(node, parent) {
            if (node.range[0] &#x3c;= index &#x26;&#x26; index &#x3c; node.range[1]) {
                result = node;
                resultParent = parent;
            } else {
                this.skip();
            }
        },
        leave(node) {
            if (node === result) {
                this.break();
            }
        }
    });

    return result ? Object.assign({ parent: resultParent }, result) : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.getText" id="apidoc.element.standard.eslint.SourceCode.prototype.getText">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>getText
        <span class="apidocSignatureSpan">(node, beforeCount, afterCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText(node, beforeCount, afterCount) {
    if (node) {
        return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
            node.range[1] + (afterCount || 0));
    }
    return this.text;


}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.SourceCode.prototype.isSpaceBetweenTokens" id="apidoc.element.standard.eslint.SourceCode.prototype.isSpaceBetweenTokens">
        function <span class="apidocSignatureSpan">standard.eslint.SourceCode.prototype.</span>isSpaceBetweenTokens
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSpaceBetweenTokens(first, second) {
    const text = this.text.slice(first.range[1], second.range[0]);

    return /\s/.test(text.replace(/\/\*.*?\*\//g, &#x22;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.standard.eslint.linter" id="apidoc.module.standard.eslint.linter">module standard.eslint.linter</a></h1>


    <h2>
        <a href="#apidoc.element.standard.eslint.linter.defaults" id="apidoc.element.standard.eslint.linter.defaults">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function () {
    return require(&#x22;../conf/eslint-recommended&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.defineRule" id="apidoc.element.standard.eslint.linter.defineRule">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defineRule
        <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRule = function (ruleId, ruleModule) {
    rules.define(ruleId, ruleModule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.defineRules" id="apidoc.element.standard.eslint.linter.defineRules">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>defineRules
        <span class="apidocSignatureSpan">(rulesToDefine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRules = function (rulesToDefine) {
    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId =&#x3e; {
        defineRule(ruleId, rulesToDefine[ruleId]);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getAllComments" id="apidoc.element.standard.eslint.linter.getAllComments">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getAllComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllComments = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getAncestors" id="apidoc.element.standard.eslint.linter.getAncestors">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getAncestors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAncestors = function () {
    return traverser.parents();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getComments" id="apidoc.element.standard.eslint.linter.getComments">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getDeclaredVariables" id="apidoc.element.standard.eslint.linter.getDeclaredVariables">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getDeclaredVariables
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDeclaredVariables = function (node) {
    return (scopeManager &#x26;&#x26; scopeManager.getDeclaredVariables(node)) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getFilename" id="apidoc.element.standard.eslint.linter.getFilename">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    if (typeof currentFilename === &#x22;string&#x22;) {
        return currentFilename;
    }
    return &#x22;&#x3c;input&#x3e;&#x22;;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getFirstToken" id="apidoc.element.standard.eslint.linter.getFirstToken">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFirstToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstToken = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getFirstTokens" id="apidoc.element.standard.eslint.linter.getFirstTokens">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getFirstTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getJSDocComment" id="apidoc.element.standard.eslint.linter.getJSDocComment">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getJSDocComment
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSDocComment = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getLastToken" id="apidoc.element.standard.eslint.linter.getLastToken">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getLastToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastToken = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getLastTokens" id="apidoc.element.standard.eslint.linter.getLastTokens">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getLastTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getNodeByRangeIndex" id="apidoc.element.standard.eslint.linter.getNodeByRangeIndex">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getNodeByRangeIndex
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeByRangeIndex = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getRules" id="apidoc.element.standard.eslint.linter.getRules">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRules = function () {
    return rules.getAllLoadedRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getScope" id="apidoc.element.standard.eslint.linter.getScope">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScope = function () {
    const parents = traverser.parents();

    // Don&#x27;t do this for Program nodes - they have no parents
    if (parents.length) {

        // if current node introduces a scope, add it to the list
        const current = traverser.current();

        if (currentConfig.parserOptions.ecmaVersion &#x3e;= 6) {
            if ([&#x22;BlockStatement&#x22;, &#x22;SwitchStatement&#x22;, &#x22;CatchClause&#x22;, &#x22;FunctionDeclaration&#x22;, &#x22;FunctionExpression&#x22;, &#x22;ArrowFunctionExpression
&#x22;].indexOf(current.type) &#x3e;= 0) {
                parents.push(current);
            }
        } else {
            if ([&#x22;FunctionDeclaration&#x22;, &#x22;FunctionExpression&#x22;, &#x22;ArrowFunctionExpression&#x22;].indexOf(current.type) &#x3e;= 0) {
                parents.push(current);
            }
        }

        // Ascend the current node&#x27;s parents
        for (let i = parents.length - 1; i &#x3e;= 0; --i) {

            // Get the innermost scope
            const scope = scopeManager.acquire(parents[i], true);

            if (scope) {
                if (scope.type === &#x22;function-expression-name&#x22;) {
                    return scope.childScopes[0];
                }
                return scope;

            }

        }

    }

    return currentScopes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getSource" id="apidoc.element.standard.eslint.linter.getSource">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSource
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSource = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getSourceCode" id="apidoc.element.standard.eslint.linter.getSourceCode">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSourceCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceCode = function () {
    return sourceCode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getSourceLines" id="apidoc.element.standard.eslint.linter.getSourceLines">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getSourceLines
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceLines = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokenAfter" id="apidoc.element.standard.eslint.linter.getTokenAfter">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenAfter = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokenBefore" id="apidoc.element.standard.eslint.linter.getTokenBefore">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenBefore = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokenByRangeStart" id="apidoc.element.standard.eslint.linter.getTokenByRangeStart">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokenByRangeStart
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenByRangeStart = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokens" id="apidoc.element.standard.eslint.linter.getTokens">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokensAfter" id="apidoc.element.standard.eslint.linter.getTokensAfter">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensAfter = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokensBefore" id="apidoc.element.standard.eslint.linter.getTokensBefore">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBefore = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.getTokensBetween" id="apidoc.element.standard.eslint.linter.getTokensBetween">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>getTokensBetween
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBetween = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.markVariableAsUsed" id="apidoc.element.standard.eslint.linter.markVariableAsUsed">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>markVariableAsUsed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markVariableAsUsed = function (name) {
    const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures &#x26;&#x26; currentConfig.parserOptions.ecmaFeatures.globalReturn,
        specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === &#x22;module&#x22;;
    let scope = this.getScope(),
        i,
        len;

    // Special Node.js scope means we need to start one level deeper
    if (scope.type === &#x22;global&#x22; &#x26;&#x26; specialScope) {
        scope = scope.childScopes[0];
    }

    do {
        const variables = scope.variables;

        for (i = 0, len = variables.length; i &#x3c; len; i++) {
            if (variables[i].name === name) {
                variables[i].eslintUsed = true;
                return true;
            }
        }
    } while ((scope = scope.upper));

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.report" id="apidoc.element.standard.eslint.linter.report">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>report
        <span class="apidocSignatureSpan">(ruleId, severity, node, location, message, opts, fix, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (ruleId, severity, node, location, message, opts, fix, meta) {
    if (node) {
        assert.strictEqual(typeof node, &#x22;object&#x22;, &#x22;Node must be an object&#x22;);
    }

    if (typeof location === &#x22;string&#x22;) {
        assert.ok(node, &#x22;Node must be provided when reporting error if location is not provided&#x22;);

        meta = fix;
        fix = opts;
        opts = message;
        message = location;
        location = node.loc.start;
    }

    // Store end location.
    const endLocation = location.end;

    location = location.start || location;

    if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
        return;
    }

    if (opts) {
        message = message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, (fullMatch, term) =&#x3e; {
            if (term in opts) {
                return opts[term];
            }

            // Preserve old behavior: If parameter name not provided, don&#x27;t replace it.
            return fullMatch;
        });
    }

    const problem = {
        ruleId,
        severity,
        message,
        line: location.line,
        column: location.column + 1,   // switch to 1-base instead of 0-base
        nodeType: node &#x26;&#x26; node.type,
        source: sourceCode.lines[location.line - 1] || &#x22;&#x22;
    };

    // Define endLine and endColumn if exists.
    if (endLocation) {
        problem.endLine = endLocation.line;
        problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base
    }

    // ensure there&#x27;s range and text properties, otherwise it&#x27;s not a valid fix
    if (fix &#x26;&#x26; Array.isArray(fix.range) &#x26;&#x26; (typeof fix.text === &#x22;string&#x22;)) {

        // If rule uses fix, has metadata, but has no metadata.fixable, we should throw
        if (meta &#x26;&#x26; !meta.fixable) {
            throw new Error(&#x22;Fixable rules should export a `meta.fixable` property.&#x22;);
        }

        problem.fix = fix;
    }

    messages.push(problem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.reset" id="apidoc.element.standard.eslint.linter.reset">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    this.removeAllListeners();
    messages = [];
    currentConfig = null;
    currentScopes = null;
    scopeManager = null;
    traverser = null;
    reportingConfig = [];
    sourceCode = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.standard.eslint.linter.verify" id="apidoc.element.standard.eslint.linter.verify">
        function <span class="apidocSignatureSpan">standard.eslint.linter.</span>verify
        <span class="apidocSignatureSpan">(textOrSourceCode, config, filenameOrOptions, saveState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (textOrSourceCode, config, filenameOrOptions, saveState) {
    const text = (typeof textOrSourceCode === &#x22;string&#x22;) ? textOrSourceCode : null;
    let ast,
        parseResult,
        shebang,
        allowInlineConfig;

    // evaluate arguments
    if (typeof filenameOrOptions === &#x22;object&#x22;) {
        currentFilename = filenameOrOptions.filename;
        allowInlineConfig = filenameOrOptions.allowInlineConfig;
        saveState = filenameOrOptions.saveState;
    } else {
        currentFilename = filenameOrOptions;
    }

    if (!saveState) {
        this.reset();
    }

    // search and apply &#x22;eslint-env *&#x22;.
    const envInFile = findEslintEnv(text || textOrSourceCode.text);

    if (envInFile) {
        if (!config || !config.env) {
            config = Object.assign({}, config || {}, { env: envInFile });
        } else {
            config = Object.assign({}, config);
            config.env = Object.assign({}, config.env, envInFile);
        }
    }

    // process initial config to make it safe to extend
    config = prepareConfig(config || {});

    // only do this for text
    if (text !== null) {

        // there&#x27;s no input, just exit here
        if (text.trim().length === 0) {
            sourceCode = new SourceCode(text, blankScriptAST);
            return messages;
        }

        parseResult = parse(
            stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, (match, captured) =&#x3e; {
                shebang = captured;
                return `//${captured}`;
            }),
            config,
            currentFilename
        );

        // if this result is from a parseForESLint() method, normalize
        if (parseResult &#x26;&#x26; parseResult.ast) {
            ast = parseResult.ast;
        } else {
            ast = parseResult;
            parseResult = null;
        }

        if (ast) {
            sourceCode = new SourceCode(text, ast);
        }

    } else {
        sourceCode = textOrSourceCode;
        ast = sourceCode.ast;
    }

    // if espree failed to parse the file, there&#x27;s no sense in setting up rules
    if (ast) {

        // parse global comments and modify config
        if (allowInlineConfig !== false) {
            config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
        }

        // ensure that severities are normalized in the config
        ConfigOps.normalize(config);

        // enable appropriate rules
        Object.keys(config.rules).filter(key =&#x3e; getRuleSeverity(config.rules[key]) &#x3e; 0).forEach(key =&#x3e; {
            let ruleCreator;

            ruleCreator = rules.get(key);

            if (!ruleCreator) {
                const replacementMsg = getRuleReplacementMessage(key);

                if (replacementMsg) {
                    ruleCreator = createStubRule(replacementMsg);
                } else {
                    ruleCreator = createStubRule(`Definition for rule &#x27;${key}&#x27; was not found`);
                }
                rules.define(key, ruleCreator);
            }

            const severity = getRuleSeverity(config.rules[key]);
            const options = getRuleOptions(config.rules[key]);

            try {
                const ruleContext = new RuleContext(
                    key, api, severity, options,
                    config.settings, config.parserOptions, config.parser,
                    ruleCreator.meta,
                    (parseResult &#x26;&#x26; parseResult.services ? parseResult.services : {})
                );

                const rule = ruleCreator.create ? ruleCreator.create(ruleContext)
                    : ruleCreator(ruleContext);

                // add all the selectors from the rule as listeners
                Object.keys(rule).forEach(selector =&#x3e; {
                    api.on(selector, timing.enabled
                        ? timing.time(key, rule[selector])
                        : rule[selector]
                    );
                });
            } catch (ex) {
                ex.message = `Error while loading rule &#x27;${key}&#x27;: ${ex.message}`;
                throw ex;
            } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
